{"pages":[],"posts":[{"title":"类文件结构","text":"class类文件结构 知识点 class文件是一组以8位字节为基础的二进制流 class文件格式采用一种类似于c语言结构体的伪结构来存储数据，只包含两种类型：无符号数和表 无符号数:属于基本的数据类型，u1，u2到u8分别代表1，2，8个字节的无符号数，可以用来描述数字、索引引用、数量值或者utf-8编码构成的字符串值 表：由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性的以“_info”结尾 整个class文件本质上就是一张表 字节码 魔数与class文件的版本 每个class文件开头4个字节成为魔数，唯一的作用进行身份识别（比文件扩展名更加安全，因为扩展名可以随意修改） 第5、6个字节表示次版本号 第7、8个字节表示主版本号（JAVA主版本号从45开始） java的魔数是“0xCAFEBABE” 常量池 主次版本后就是常量池的入口，入口放置u2，表示常量池容量，从1开始 主要存放两大类常量：字面量和符号引用 字面量：接近java语言层面的常量概念，如：文本字符串、声明为final的常量值 符号引用：属于编译原理方面的概念，如：类和接口的全限定名、字段的名称和描述符、方法的名称和描述 符 访问标志 常量池结束后紧接的两个字节 这个标志用于识别一些类或者接口层次的访问信息，如：这个class是类还是接口、是否定义为public、是否定义为abstract类型、是否被声明为final 类索引、父类索引、接口索引 访问标志后的三个u2类型的数据分别表示类索引、父类索引、接口索引数量 字段表集合 方法表集合 属性表集合 字节码指令 知识点 java虚拟机指令：操作码（opcode）+操作数（oprands） 操作码大小为1个字节，所以操作码指令总数不可能超过256 加载和存储指令 加载（变量：load 常量:ipush）和存储（store）指令用于将数据在栈帧的局部变量表和操作数栈之间传输数据 slot_0 存放的四this 指令运算集 如果某个操作结果没有明确的数学定义，则使用NaN表示，NaN参与的所有运算结果都是NaN 类型转换指令 Java虚拟机支持的直接转换（无需显示转换）：小范围类型到大范围类型的安全转换 int到long、float、double long到float、double float到double 窄化类型转换（大范围类型到小范围类型的不安全转换）例如：i2b、l2i 转换结果可能产生不同的正负号、不同的数量级、导致精度丢失 long转int：丢弃高位，剩下32位，最高位则位正负号，则有可能出现与原来相反的符号 浮点数转整型： 浮点数是NaN，转换结果是0 浮点值不是无穷大的话，舍弃小数位的结果在整型范围内则直接舍弃小数位 浮点值不是无穷大的话，舍弃小数位的结果不在整型范围内，则根据浮点数的符号，表示位整型的最大或最小正数 对象创建与访问指令 创建类实例：new 创建数组：newarray、anewarray 访问类字段（static）：getstatic、putstatic 访问实例字段：getfield、putfield 将数组元素加载到操作数栈：_aload 将操作数栈中的元素存到数组中：_astore 取数组长度指令：arraylength 检查类实例类型：instanceof、checkcast 操作数栈管理指令 栈顶出栈元素：pop、pop2（出栈两个元素） 复制栈顶的值并重新压入栈中：dup、dup2（复制栈顶两个元素） 互换栈顶两个元素：swap 控制转移指令 条件分支：ifeq、iflt、ifnull 复合条件分支：tableswitch、lookupswitch 无条件分支：goto、goto_w、ret 方法调用和返回指令 invokevirtual 调用对象实例方法 invokeinterface 调用接口方法（找到实现此接口的方法进行调用） invokespecial 调用需要特殊处理的方法，例如：实例初始化方法、私有方法和父方法 invokestatic 调用类方法 invokedynamic ireturn（bool、byte、char、short、int）返回值类型 lreturn、freturn、dreturn、areturn 异常处理指令 同步指令 java虚拟机可以支持方法级同步和方法内部一段指令的同步，这两种同步都使用管程（Monitor）来支持","link":"/2019/12/27/java虚拟机/类文件结构/"},{"title":"虚拟机加载机制","text":"概述 类型的加载、连接和初始化都是在程序运行期间完成的（动态加载、动态连接），虽然会增加性能的开销，但是会提高java语言的动态扩展性 加载类的时机 有且只有以下5种情况类立即开始初始化（加载、验证、准备已完成），称为主动引用： 遇到new、getstatic、putstatic、或invokestatic这4条字节指令码时，如果类没有进行初始化则触发其初始化–首次访问类的静态变量或者静态方法时、new 使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行过初始化则立即初始化–Class.forName 当初始化一个类的时候其父类还没有进行初始化则对其父类先进行初始化（类对此有要求而接口没有，接口在用到其父类时再进行初始化）–子类初始化会连动父类初始化 main方法所在的类首先进行初始化 jdk1.7的动态语言支持，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先初始化 除此之外，所有引用类的方式都不会触发初始化，这种引用方式称为被动引用，例如： 引用静态字段的时候只有定义静态字段的类会初始化，其子类在引用的时候子类不会初始化，只会初始化定义静态字段的父类 SuperClass[] sca=new SuperClass[]; 不会触发SuperClass的初始化（创建动作是newarray，不是new） 在一个类种有final修饰的静态属性，当对此属性引用时不会触发该类的初始化，因为在编译期间将此静态属性的值存储到了Notinitialization类的常量池中，此时引用的是Notinitialization的值，与定义此静态属性的类已经没有任何联系了 对象.class 类加载器的loadClass方法 Class.forName()的第2个参数是false时 类加载的过程 加载 instanceKlass这样的元数据是存储在方法去内的，_java_mirror存储在Heap中，并且互相持有对方的指针 加载只是类加载的一个阶段 加载阶段，虚拟机需要完成三件事情：获取二进制字节流–&gt;根据二进制字节流构造数据结构–&gt;方法区中生成一个java.lang.Class对象 通过一个类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口 加载阶段和验证的部分阶段是交叉进行的 验证–链接 验证类是否复合java虚拟机规范，安全性检查 文件格式验证：魔数、主次版本校验 元数据验证 字节码验证 符号引用验证 准备–链接 此阶段为类变量（static）分配内存（1.6之前在方法区中，1.7之后在Heap中），赋初始值（真正赋值则是在()方法中） final修饰的static变量则在准备阶段就进行了真正赋值（基本数据类型+String），除此之外则在初始化的时候赋值 解析–链接 将常量池中符号引用替换为直接引用的 初始化 初始化即调用()V，虚拟机保证这个类的构造方法线程安全 类加载器 ​","link":"/2019/12/27/java虚拟机/虚拟机类加载机制/"},{"title":"杂","text":"代码书写优化 尽量不要在finally中书写return语句 调用类的静态属性尽量用类调用而不是用对象来调用","link":"/2019/12/26/杂谈/杂/"},{"title":"单例模式","text":"延迟加载的单例模式123456789101112131415public class Singoleton { //私有化构造方法 private Singoleton() { } //内部静态类不会随着外部类的初始化而初始化，只有在第一次访问内部类的时候才会初始化 private static class LazyHolder { private static final Singoleton SINGOLETON = new Singoleton(); } //获取单例类的实例 public static Singoleton getInstance() { return LazyHolder.SINGOLETON; }}","link":"/2019/12/30/设计模式/单例模式/"},{"title":"x的平方根","text":"题目 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 12输入: 4输出: 2 示例 2: 1234输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 思路：** 穷举法，从1开始算平方，找到第一个大于指定的i，然后减一就是答案 实现： 123456789101112131415package array.x的平方根;public class Solution { public int mySqrt(int x) { int result = 0; for (int i = 1; i &lt; 1000000; i++) { long num = (long)i * i; if (num &gt; x){ result = i - 1; break; } } return result; }}","link":"/2020/01/05/算法/数组/x 的平方根/"},{"title":"Excel表列名称","text":"题目 给定一个正整数，返回它在 Excel 表中相对应的列名称。 例如， 1 -&gt; A 2 -&gt; B 3 -&gt; C ... 26 -&gt; Z 27 -&gt; AA 28 -&gt; AB ... 示例 1: 12输入: 1输出: &quot;A&quot; 示例 2: 12输入: 28输出: &quot;AB&quot; 示例 3: 12输入: 701输出: &quot;ZY&quot; 思路： 因为A=1而A下标对应的是0，因此每一位的计算都要减一 实现： 12345678910111213141516class Solution { public String convertToTitle(int n) { String[] orig = {\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"}; //存放结果 StringBuilder sb = new StringBuilder(); while (n &gt; 0) { n--; int div = n % 26; sb.append(orig[div]); n /= 26; } return sb.reverse().toString(); }}","link":"/2020/01/06/算法/数组/Excel列表名称/"},{"title":"买卖股票的最佳时机2","text":"题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路： 再降价点前卖掉，到降价点时买入 实现: 1234567891011121314151617181920212223242526272829303132333435class Solution { public int maxProfit(int[] prices) { //记录总利润 int profit = 0; //当数组位空或者只有一个数字时 if (prices.length &lt;= 1) return 0; //记录购入时的价钱 int buy = -1; for (int i = 1; i &lt; prices.length; i++) { //找到降价点 if (prices[i - 1] &gt; prices[i]) { //最初买入 if (buy == -1) buy = prices[i]; else { profit = profit + prices[i - 1] - buy; buy = prices[i]; } } else { if (buy == -1) buy = prices[i - 1]; } } //比较最后一个数字是否比买入时候贵 if (prices[prices.length - 1] &gt; buy) profit = profit + prices[prices.length - 1] - buy; return profit; }}","link":"/2020/01/05/算法/数组/买卖股票的最佳时机2/"},{"title":"两数之和 II - 输入有序数组","text":"题目 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 123输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 思路： 列表从后往前遍历，看看目标减去当前值是否在当前值前面的集合里 暴力两层循环，查找是否存在加起来的和等于目标值 实现： 123456789101112131415161718192021class Solution { public int[] twoSum(int[] numbers, int target) { int[] res = new int[2]; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int number : numbers) { list.add(number); } for (int i = list.size() - 1; i &gt; 0; i--) { int sub = target - list.get(i); list.remove(i); if (list.contains(sub)) { res[0] = list.indexOf(sub) + 1; res[1] = i + 1; break; } } return res; }} 12345678910111213141516171819202122class Solution { public int[] twoSum(int[] numbers, int target) { int[] res = new int[2]; boolean flag = true; for (int i = 0; i &lt; numbers.length - 1; i++) { if (flag) { //判断是否找到所需结果 for (int j = i + 1; j &lt; numbers.length; j++) { if (numbers[i] + numbers[j] == target) { res[0] = i + 1; res[1] = j + 1; flag = false; break; }else if(numbers[i] + numbers[j] &gt; target) //当加起来的和超过目标值结束此轮循环 break; } } else break; } return res; }}","link":"/2020/01/06/算法/数组/两数之和 II - 输入有序数组/"},{"title":"二进制求和","text":"题目 给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1: 12输入: a = &quot;11&quot;, b = &quot;1&quot;输出: &quot;100&quot; 示例 2: 12输入: a = &quot;1010&quot;, b = &quot;1011&quot;输出: &quot;10101&quot; 思路： 从低位到高位依次计算 设置当前位num 设置进位carry 代码： 1234567891011121314151617181920212223242526272829303132333435363738package array.二进制求和;public class Solution { public String addBinary(String a, String b) { int n = a.length() - 1; int m = b.length() - 1; int carry = 0; StringBuilder sb = new StringBuilder(); while (n &gt;= 0 &amp;&amp; m &gt;= 0) { int num = a.charAt(n) - '0' + b.charAt(m) - '0' + carry; carry = num / 2; num = num % 2; sb.append(num); n--; m--; } while (n &gt;= 0) { int num = a.charAt(n) + carry - '0'; carry = num / 2; num = num % 2; sb.append(num); n--; } while (m &gt;= 0) { int num = b.charAt(m) - '0' + carry; carry = num / 2; num = num % 2; sb.append(num); m--; } if (carry &gt; 0) sb.append(carry); return sb.reverse().toString(); }}","link":"/2020/01/04/算法/数组/二进制求和/"},{"title":"最小栈","text":"题目 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 示例: 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 思路： 建立两个栈，一个保存栈的值，另一个保存最小值 实现： 123456789101112131415161718192021222324252627282930313233class MinStack { Stack&lt;Integer&gt; stack; Stack&lt;Integer&gt; min; /** * initialize your data structure here. */ public MinStack() { stack = new Stack&lt;&gt;(); min = new Stack&lt;&gt;(); } public void push(int x) { stack.push(x); if (min.isEmpty() || min.peek() &gt;= x) min.push(x); } public void pop() { int num = stack.pop(); if (!min.isEmpty() &amp;&amp; min.peek() == num) min.pop(); } public int top() { return stack.peek(); } public int getMin() { return min.peek(); }}","link":"/2020/01/06/算法/数组/最小栈/"},{"title":"买卖股票的最佳时机","text":"题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2:** 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路： 找出后面的值减去前面值的最大值 实现： 12345678910111213class Solution { public int maxProfit(int[] prices) { int maxNum = 0; for (int i = 0; i &lt; prices.length - 1; i++) { for (int j = i + 1; j &lt; prices.length; j++) { int num = prices[j] - prices[i]; maxNum = num &gt; maxNum ? num : maxNum; } } return maxNum; }}","link":"/2020/01/05/算法/数组/买卖股票的最佳时机/"},{"title":"最后一个单词的长度","text":"题目 给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明： 一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 12输入: &quot;Hello World&quot;输出: 5 思路：** 分割成string数组，直接输出最后一个位置单词的长度 实现： 1234567891011package array.最后一个单词的长度;public class Solution { public int lengthOfLastWord(String s) { String[] split = s.split(\" \"); if (split.length &gt; 0) return split[split.length - 1].length(); else return 0; }}","link":"/2020/01/04/算法/数组/最后一个单词的长度/"},{"title":"合并两个有序数组","text":"题目 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例： 123456789输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路： 先插入数字，然后整体排序 一边比较一边插入 实现： 12345678910111213141516171819202122232425262728293031package array.合并两个有序数组;public class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { //从数组尾端开始比较 int i = m - 1, j = n - 1, flag = 0; while (i &gt;= 0 &amp;&amp; j &gt;= 0) { if (nums1[i] &lt;= nums2[j]) { insertNum(nums1, i + 1, nums2[j]); j--; flag++; } else i--; } //检查nums2中元素是否全部插入nums1 if (flag != n) { for (int k = n - flag - 1; k &gt;= 0; k--) { insertNum(nums1, 0, nums2[k]); } } } //数组插入下标为index位置元素num private void insertNum(int[] nums, int index, int num) { for (int i = nums.length - 1; i &gt; index; i--) { nums[i] = nums[i - 1]; } nums[index] = num; }}","link":"/2020/01/04/算法/数组/合并两个有序数组/"},{"title":"相交数组","text":"题目 编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 123输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 1234输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存 思路： 获取链表长度，然后从等长的长度开始遍历，寻找完全相同的节点 实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { //存放返回结果 ListNode res = null; //判断链表是否为空 if (headA == null || headB == null) return null; //获取链表长度 int lenA = getLength(headA); int lenB = getLength(headB); //创建遍历指针 ListNode nodeA = headA; ListNode nodeB = headB; //将链表调整到相等的长度 while (lenA != lenB) { if (lenA &gt; lenB) { nodeA = nodeA.next; lenA--; } else { nodeB = nodeB.next; lenB--; } } //遍历链表并比较 while (nodeA != null) { if (nodeA == nodeB) { res = nodeA; break; } nodeA = nodeA.next; nodeB = nodeB.next; } return res; } public static int getLength(ListNode node) { int len = 0; while (node != null) { len++; node = node.next; } return len; }}class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; }}","link":"/2020/01/06/算法/数组/相交数组/"},{"title":"杨辉三角","text":"题目 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 思路：** 根据动态规划的思想，按照杨辉三角的规则计算下一行的值 实现： 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.List;class Solution { public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) { //建立存放返回结果的集合 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (numRows == 0) return res; //添加杨辉三角的第一行（此时的杨辉三角至少有一行） List&lt;Integer&gt; firstRow = new ArrayList&lt;&gt;(); firstRow.add(1); res.add(firstRow); //处理后面的行 for (int i = 1; i &lt; numRows; i++) { List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); row.add(1); //利用杨辉三角的规则计算并添加下一行元素 for (int j = 0; j &lt; res.get(i - 1).size() - 1; j++) { int num = res.get(i - 1).get(j) + res.get(i - 1).get(j + 1); row.add(num); } //添加最后一列的1 row.add(1); res.add(row); } return res; }}","link":"/2020/01/05/算法/数组/杨辉三角/"},{"title":"杨辉三角2","text":"题目 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 12输入: 3输出: [1,3,3,1] 思路：** 实现： 1234567891011121314151617181920212223242526import java.util.ArrayList;import java.util.List;class Solution { public List&lt;Integer&gt; getRow(int rowIndex) { //建立存放结果的集合 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); //添加第一行元素 List&lt;Integer&gt; firstRow = new ArrayList&lt;&gt;(); firstRow.add(1); res.add(firstRow); //根据杨辉三角的规则添加后面的行 for (int i = 1; i &lt;= rowIndex; i++) { List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); row.add(1); for (int j = 0; j &lt; res.get(i - 1).size() - 1; j++) { int num = res.get(i - 1).get(j) + res.get(i - 1).get(j + 1); row.add(num); } row.add(1); res.add(row); } return res.get(rowIndex); }}","link":"/2020/01/05/算法/数组/杨辉三角2/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"虚拟机","slug":"虚拟机","link":"/tags/虚拟机/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"数组","slug":"数组","link":"/tags/数组/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"},{"name":"虚拟机","slug":"java/虚拟机","link":"/categories/java/虚拟机/"},{"name":"杂谈","slug":"java/杂谈","link":"/categories/java/杂谈/"},{"name":"单例模式","slug":"设计模式/单例模式","link":"/categories/设计模式/单例模式/"},{"name":"算法","slug":"算法","link":"/categories/算法/"},{"name":"数组","slug":"算法/数组","link":"/categories/算法/数组/"}]}