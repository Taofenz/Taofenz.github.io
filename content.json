{"pages":[{"title":"多线程","text":"实现多线程的方式 ：2种 实现Runnable接口–推荐选择 123456789101112131415/** * 描述： 用Runnable方式创建线程 */public class RunnableStyle implements Runnable { @Override public void run() { System.out.println(\"用Runnable方式创建线程\"); } public static void main(String[] args) { Thread thread = new Thread(new RunnableStyle()); thread.start(); }} 优点 更加解耦 继承Thread类每次新建一个独立的线程，而用Runnable方式创建线程可以使用线程池统一管理，减少了线程创建、销毁的开支，性能更好 java只支持单继承，继承Thread类限制了扩展性，而用Runnable方式创建线程则更加灵活 继承Thread类 1234567891011121314/** * 描述： 继承Thread类创建线程 */public class ThreadStyle extends Thread { @Override public void run() { System.out.println(\"继承Thread类创建线程\"); } public static void main(String[] args) { new ThreadStyle().run(); }} 对比 方法一调用target.run(); 方法二：重写run()方法 线程同步方式—-3种 同步代码块 123synchronized (同步锁){ //锁对象可以是任意类型的对象 //需要同步的代码块 } 123456789101112131415161718192021222324252627282930313233343536public class Ticket implements Runnable { //定义一个线程共享的数据 private int ticket = 100; //定义同步锁对象 String lock = \"lock\"; @Override public void run() { while (true) { synchronized (lock) { if (ticket &gt; 0) { try { Thread.sleep(30); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程名称：\" + Thread.currentThread().getName() + \"正在出售第\" + ticket + \"张票\"); ticket--; } } } }}public class Main { public static void main(String[] args) { Ticket t = new Ticket(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); }} 同步方法—-锁对象：this 12345678910111213141516171819202122232425public class Ticket implements Runnable { //定义一个线程共享的数据 private int ticket = 100; @Override public void run() { while (true) { //锁对象是this payTicket(); } } private /*static*/ synchronized void payTicket(){ if (ticket &gt; 0) { try { Thread.sleep(30); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程名称：\" + Thread.currentThread().getName() + \"正在出售第\" + ticket + \"张票\"); ticket--; } }} 锁机制—–Lock锁 12345678910111213141516171819202122232425262728293031import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Ticket implements Runnable { //定义一个线程共享的数据 private int ticket = 100; //定义Lock的实现对象 Lock lock = new ReentrantLock(); @Override public void run() { while (true) { //加锁 lock.lock(); if (ticket &gt; 0) { try { Thread.sleep(30); System.out.println(\"线程名称：\" + Thread.currentThread().getName() + \"正在出售第\" + ticket + \"张票\"); ticket--; } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); //好处是无论代码是否出现异常都会释放锁 } } } }} 线程状态 等待（wait）与唤醒（notify） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ProducerConsumer { public static void main(String[] args) { //创建一个锁对象 Object obj = new Object(); //创建消费者线程 new Thread(new Runnable() { @Override public void run() { while (true) { synchronized (obj) { System.out.println(\"到了包子铺，等待老板做包子\"); //等待老板做包子 try { obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"包子到手了，开始吃包子\"); System.out.println(\"=============================================================\"); } } } }).start(); //创建生产者线程 new Thread(new Runnable() { @Override public void run() { while (true) { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (obj) { System.out.println(\"包子做好了,通知消费者\"); //通知消费者 obj.notify(); } } } }).start(); }} 进入计时等待的方式有两种 sleep（long time）方法，在毫秒值结束以后，线程进入到runnable/blocked状态 wait（long time）方法，在毫秒值结束后， 线程进入到runnable/blocked状态，无需notify唤醒 线程不再活动，不参与调度，进入wait set中，不会浪费cpu资源， 唤醒的方法 void notify（） 唤醒此对象监视器上等待的单个线程 将等待的线程从wait set释放出来（选取等待时间最长的），如果能获取锁则直接进入Runnable状态，否则进入entry set，从Waiting状态变为Blocked状态 void notifyall（） 唤醒此对象监视器上等待的全部线程 wait()和notify()必须调用同一个锁对象，并且必须在同步代码块或者同步函数中使用，且通过锁来调用这两个方法 线程池 创建 123456789101112131415import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPool { public static void main(String[] args) { //创建线程池 ExecutorService executorService = Executors.newFixedThreadPool(2); executorService.submit(new RunnableStyle()); executorService.submit(new RunnableStyle()); executorService.submit(new RunnableStyle()); //关闭线程池（不推荐） executorService.shutdown(); }} Java内存模型/JMM———是一套规范，和JVM区别开来 对共享数据的可见性、原子性、顺序性的保障 主要涉及synchronized、volatile 线程局部变量外，剩下的变量基本都在主内存中 JMM内存模型与计算机内存架构的关系 JMM内存操作的8个原子操作 在执行lock时，会先把线程中的副本值删除 在执行unlock时，会先把线程中的值同步到共享变量中 volatile会将各个线程里的副本实效，然后重新读取主内存中的值 synchronized的特性 可重入性 概念：一个线程可以多次执行synchronized，重复获取同一把锁","link":"/多线程/多线程.html"}],"posts":[{"title":"位运算","text":"按位与 &amp;在进行位运算的时候要把数据转换成二进制的补码形式（两位同为1结果为1），运算结束后再转换为10进制返回 1233的二进制 ：0b000000000000000000000000000000114的二进制 ：0b000000000000000000000000000001003 &amp; 4结果 ：0b00000000000000000000000000000000 12int res = 3 &amp; 4;System.out.println(res1); //结果为0 应用： n &amp; 1 可以计算n的二进制n/2的余数（包括带符号数） 按位或 |在进行位运算的时候要把数据转换成二进制的补码形式（两位只要有1位为1结果为1），运算结束后再转换为10进制返回 1233的二进制 ：0b000000000000000000000000000000114的二进制 ：0b000000000000000000000000000001003 | 4结果 ：0b00000000000000000000000000000111 12int res = 3 | 4;System.out.println(res1); //结果为7 按位异或 ^在进行位运算的时候要把数据转换成二进制的补码形式（两位相同为0，不同为1），运算结束后再转换为10进制返回 1233的二进制 ：0b000000000000000000000000000000114的二进制 ：0b000000000000000000000000000001003 ^ 4结果 ：0b00000000000000000000000000000111 12int res = 3 ^ 4;System.out.println(res1); //结果为7 **应用\\ 一般应用到加密（a两次异或b 结果还是a a ^ b ^ b == a） 算法题：实现两个变量值的交换 123a = a ^ b;b = a ^ b; //b = a ^ b ^ b = aa = a ^ b; //a = a ^ b ^ a = b 按位取反 ~ 单目运算符在进行位运算的时候要把数据转换成二进制的补码形式（0变1，1变0），运算结束后 再转换为10进制返回 123的二进制 ：0b00000000000000000000000000000011~3 的结果： 0b11111111111111111111111111111100 12int res1 = ~3;System.out.println(res1); //结果为-4 位运算 &lt;&lt; &gt;&gt; &gt;&gt;&gt; &lt;&lt; 右边用0填充 n &lt;&lt; i n * 2 的i次幂 &gt;&gt; 符号位是几就用几填充 n &gt;&gt; i n / 2 的i次幂 &gt;&gt;&gt; 无符号右移———左边用0填充 n &gt;&gt; i n / 2 的i次幂","link":"/2020/01/07/杂谈/位运算/"},{"title":"类文件结构","text":"class类文件结构 知识点 class文件是一组以8位字节为基础的二进制流 class文件格式采用一种类似于c语言结构体的伪结构来存储数据，只包含两种类型：无符号数和表 无符号数:属于基本的数据类型，u1，u2到u8分别代表1，2，8个字节的无符号数，可以用来描述数字、索引引用、数量值或者utf-8编码构成的字符串值 表：由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性的以“_info”结尾 整个class文件本质上就是一张表 字节码 魔数与class文件的版本 每个class文件开头4个字节成为魔数，唯一的作用进行身份识别（比文件扩展名更加安全，因为扩展名可以随意修改） 第5、6个字节表示次版本号 第7、8个字节表示主版本号（JAVA主版本号从45开始） java的魔数是“0xCAFEBABE” 常量池 主次版本后就是常量池的入口，入口放置u2，表示常量池容量，从1开始 主要存放两大类常量：字面量和符号引用 字面量：接近java语言层面的常量概念，如：文本字符串、声明为final的常量值 符号引用：属于编译原理方面的概念，如：类和接口的全限定名、字段的名称和描述符、方法的名称和描述 符 访问标志 常量池结束后紧接的两个字节 这个标志用于识别一些类或者接口层次的访问信息，如：这个class是类还是接口、是否定义为public、是否定义为abstract类型、是否被声明为final 类索引、父类索引、接口索引 访问标志后的三个u2类型的数据分别表示类索引、父类索引、接口索引数量 字段表集合 方法表集合 属性表集合 字节码指令 知识点 java虚拟机指令：操作码（opcode）+操作数（oprands） 操作码大小为1个字节，所以操作码指令总数不可能超过256 加载和存储指令 加载（变量：load 常量:ipush）和存储（store）指令用于将数据在栈帧的局部变量表和操作数栈之间传输数据 slot_0 存放的四this 指令运算集 如果某个操作结果没有明确的数学定义，则使用NaN表示，NaN参与的所有运算结果都是NaN 类型转换指令 Java虚拟机支持的直接转换（无需显示转换）：小范围类型到大范围类型的安全转换 int到long、float、double long到float、double float到double 窄化类型转换（大范围类型到小范围类型的不安全转换）例如：i2b、l2i 转换结果可能产生不同的正负号、不同的数量级、导致精度丢失 long转int：丢弃高位，剩下32位，最高位则位正负号，则有可能出现与原来相反的符号 浮点数转整型： 浮点数是NaN，转换结果是0 浮点值不是无穷大的话，舍弃小数位的结果在整型范围内则直接舍弃小数位 浮点值不是无穷大的话，舍弃小数位的结果不在整型范围内，则根据浮点数的符号，表示位整型的最大或最小正数 对象创建与访问指令 创建类实例：new 创建数组：newarray、anewarray 访问类字段（static）：getstatic、putstatic 访问实例字段：getfield、putfield 将数组元素加载到操作数栈：_aload 将操作数栈中的元素存到数组中：_astore 取数组长度指令：arraylength 检查类实例类型：instanceof、checkcast 操作数栈管理指令 栈顶出栈元素：pop、pop2（出栈两个元素） 复制栈顶的值并重新压入栈中：dup、dup2（复制栈顶两个元素） 互换栈顶两个元素：swap 控制转移指令 条件分支：ifeq、iflt、ifnull 复合条件分支：tableswitch、lookupswitch 无条件分支：goto、goto_w、ret 方法调用和返回指令 invokevirtual 调用对象实例方法 invokeinterface 调用接口方法（找到实现此接口的方法进行调用） invokespecial 调用需要特殊处理的方法，例如：实例初始化方法、私有方法和父方法 invokestatic 调用类方法 invokedynamic ireturn（bool、byte、char、short、int）返回值类型 lreturn、freturn、dreturn、areturn 异常处理指令 同步指令 java虚拟机可以支持方法级同步和方法内部一段指令的同步，这两种同步都使用管程（Monitor）来支持","link":"/2019/12/27/java虚拟机/类文件结构/"},{"title":"虚拟机加载机制","text":"概述 类型的加载、连接和初始化都是在程序运行期间完成的（动态加载、动态连接），虽然会增加性能的开销，但是会提高java语言的动态扩展性 加载类的时机 有且只有以下5种情况类立即开始初始化（加载、验证、准备已完成），称为主动引用： 遇到new、getstatic、putstatic、或invokestatic这4条字节指令码时，如果类没有进行初始化则触发其初始化–首次访问类的静态变量或者静态方法时、new 使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行过初始化则立即初始化–Class.forName 当初始化一个类的时候其父类还没有进行初始化则对其父类先进行初始化（类对此有要求而接口没有，接口在用到其父类时再进行初始化）–子类初始化会连动父类初始化 main方法所在的类首先进行初始化 jdk1.7的动态语言支持，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先初始化 除此之外，所有引用类的方式都不会触发初始化，这种引用方式称为被动引用，例如： 引用静态字段的时候只有定义静态字段的类会初始化，其子类在引用的时候子类不会初始化，只会初始化定义静态字段的父类 SuperClass[] sca=new SuperClass[]; 不会触发SuperClass的初始化（创建动作是newarray，不是new） 在一个类种有final修饰的静态属性，当对此属性引用时不会触发该类的初始化，因为在编译期间将此静态属性的值存储到了Notinitialization类的常量池中，此时引用的是Notinitialization的值，与定义此静态属性的类已经没有任何联系了 对象.class 类加载器的loadClass方法 Class.forName()的第2个参数是false时 类加载的过程 加载 instanceKlass这样的元数据是存储在方法去内的，_java_mirror存储在Heap中，并且互相持有对方的指针 加载只是类加载的一个阶段 加载阶段，虚拟机需要完成三件事情：获取二进制字节流–&gt;根据二进制字节流构造数据结构–&gt;方法区中生成一个java.lang.Class对象 通过一个类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口 加载阶段和验证的部分阶段是交叉进行的 验证–链接 验证类是否复合java虚拟机规范，安全性检查 文件格式验证：魔数、主次版本校验 元数据验证 字节码验证 符号引用验证 准备–链接 此阶段为类变量（static）分配内存（1.6之前在方法区中，1.7之后在Heap中），赋初始值（真正赋值则是在()方法中） final修饰的static变量则在准备阶段就进行了真正赋值（基本数据类型+String），除此之外则在初始化的时候赋值 解析–链接 将常量池中符号引用替换为直接引用的 初始化 初始化即调用()V，虚拟机保证这个类的构造方法线程安全 类加载器 ​","link":"/2019/12/27/java虚拟机/虚拟机类加载机制/"},{"title":"杂","text":"代码书写优化 尽量不要在finally中书写return语句 调用类的静态属性尽量用类调用而不是用对象来调用","link":"/2019/12/26/杂谈/杂/"},{"title":"单例模式","text":"延迟加载的单例模式123456789101112131415public class Singoleton { //私有化构造方法 private Singoleton() { } //内部静态类不会随着外部类的初始化而初始化，只有在第一次访问内部类的时候才会初始化 private static class LazyHolder { private static final Singoleton SINGOLETON = new Singoleton(); } //获取单例类的实例 public static Singoleton getInstance() { return LazyHolder.SINGOLETON; }}","link":"/2019/12/30/设计模式/单例模式/"},{"title":"Excel表列名称","text":"题目 给定一个正整数，返回它在 Excel 表中相对应的列名称。 例如， 1 -&gt; A 2 -&gt; B 3 -&gt; C ... 26 -&gt; Z 27 -&gt; AA 28 -&gt; AB ... 示例 1: 12输入: 1输出: &quot;A&quot; 示例 2: 12输入: 28输出: &quot;AB&quot; 示例 3: 12输入: 701输出: &quot;ZY&quot; 思路： 因为A=1而A下标对应的是0，因此每一位的计算都要减一 实现： 12345678910111213141516class Solution { public String convertToTitle(int n) { String[] orig = {\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"}; //存放结果 StringBuilder sb = new StringBuilder(); while (n &gt; 0) { n--; int div = n % 26; sb.append(orig[div]); n /= 26; } return sb.reverse().toString(); }}","link":"/2020/01/06/算法/数组/Excel列表名称/"},{"title":"三数之和","text":"题目 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 思路： 半暴力+双指针 实现: 123456789101112131415161718192021222324252627282930313233import java.util.*;public class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { Set&lt;List&lt;Integer&gt;&gt; temp = new HashSet&lt;&gt;(); if (nums == null || nums.length &lt; 3) return new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 2; i++) { int target = 0 - nums[i]; int head = i + 1; int rear = nums.length - 1; while (head &lt; rear) { if (nums[head] + nums[rear] == target) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(nums[i]); list.add(nums[head]); list.add(nums[rear]); temp.add(list); head++; rear--; } else if (nums[head] + nums[rear] &gt; target) rear--; else head++; } } List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(temp); return res; }}","link":"/2020/01/09/算法/数组/三数之和/"},{"title":"x的平方根","text":"题目 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 12输入: 4输出: 2 示例 2: 1234输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 思路：** 穷举法，从1开始算平方，找到第一个大于指定的i，然后减一就是答案 实现： 123456789101112131415package array.x的平方根;public class Solution { public int mySqrt(int x) { int result = 0; for (int i = 1; i &lt; 1000000; i++) { long num = (long)i * i; if (num &gt; x){ result = i - 1; break; } } return result; }}","link":"/2020/01/05/算法/数组/x 的平方根/"},{"title":"不同路径","text":"题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 示例 1: 12345678输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 12输入: m = 7, n = 3输出: 28 思路： 使用动态规划的思想，每个格子保存的都是到达当前格子的方法，计算每个格子的方法是左边+上边，结果就是最后格子里的数字 实现： 123456789101112131415161718192021222324252627282930class Solution { public int uniquePaths(int m, int n) { if (m == 0 &amp;&amp; n == 0) return 0; //创建dp数组(每个格子保存的都是到当前格子一共的方法数) int[][] dp = new int[m][n]; //边界循环赋值为1 for (int j = 0; j &lt; n; j++) { //第一行 dp[0][j] = 1; } for (int i = 0; i &lt; m; i++) { //第一列 dp[i][0] = 1; } //动态计算数组各个值 for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { dp[i][j] = dp[i][j - 1] + dp[i - 1][j]; } } //返回总共的值 return dp[m - 1][n - 1]; }}","link":"/2020/01/12/算法/数组/不同路径/"},{"title":"三角形最小路径和","text":"题目 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 思路： 基础dp思想 实现： 1234567891011121314151617181920212223242526272829303132333435class Solution { public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) { if (triangle == null || triangle.size() == 0) return 0; int n = triangle.size(); int[][] dp = new int[n][n]; for (int i = 0; i &lt; triangle.size(); i++) { for (int j = 0; j &lt; triangle.get(i).size(); j++) { dp[i][j] = triangle.get(i).get(j); } } //处理第一列 for (int i = 1; i &lt; n; i++) { dp[i][0] += dp[i - 1][0]; } //处理对角线列 for (int i = 1; i &lt; n; i++) { dp[i][i] += dp[i - 1][i - 1]; } //初始化动态数组 for (int i = 2; i &lt; n; i++) { for (int j = 1; j &lt; triangle.get(i).size() - 1; j++) { dp[i][j] += Math.min(dp[i - 1][j], dp[i - 1][j - 1]); } } Arrays.sort(dp[n - 1]); return dp[n - 1][0]; }}","link":"/2020/01/15/算法/数组/三角形最小路径和/"},{"title":"不同路径 II","text":"题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n 的值均不超过 100。 示例 1: 1234567891011121314输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 思路： 首先将传入的数组改造成一个dp数组 初始化第一行，假如位置是0，则变为1，遇到第一个1停止赋值，然后把此位置开始到结尾都变为0（到不了后面的格子了） 初始化第一列同理 计算整个dp数组时，如果当前位置是1，则直接赋值为0，如果是0.则把前一个和上面格子的数字加起来 返回最后一个格子的数字 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { //当数组为空或者数组没有内容或者数组首个元素为1时，直接返回0 if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0][0] == 1) return 0; //行 int m = obstacleGrid.length; //列 int n = obstacleGrid[0].length; //就把原数组当成一个dp数组，然后初始化dp数组 int j = 0; //找到第一行的障碍点 for (; j &lt; n; j++) { if (obstacleGrid[0][j] == 1) break; else obstacleGrid[0][j] = 1; //没有障碍，给赋值1 } while (j &lt; n) { obstacleGrid[0][j] = 0; //后面的格子都到不了，因此赋值为0 j++; } //找第一列的障碍点 int i = 1; for (; i &lt; m; i++) { if (obstacleGrid[i][0] == 1) break; else obstacleGrid[i][0] = 1; //没有障碍，给赋值1 } while (i &lt; m) { obstacleGrid[i][0] = 0; i++; } //计算dp数组的值 for (int k = 1; k &lt; m; k++) { for (int l = 1; l &lt; n; l++) { if (obstacleGrid[k][l] == 1) obstacleGrid[k][l] = 0; else obstacleGrid[k][l] = obstacleGrid[k - 1][l] + obstacleGrid[k][l - 1]; } } //返回结果 return obstacleGrid[m - 1][n - 1]; }}","link":"/2020/01/12/算法/数组/不同路径 II/"},{"title":"买卖股票的最佳时机2","text":"题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路： 再降价点前卖掉，到降价点时买入 实现: 1234567891011121314151617181920212223242526272829303132333435class Solution { public int maxProfit(int[] prices) { //记录总利润 int profit = 0; //当数组位空或者只有一个数字时 if (prices.length &lt;= 1) return 0; //记录购入时的价钱 int buy = -1; for (int i = 1; i &lt; prices.length; i++) { //找到降价点 if (prices[i - 1] &gt; prices[i]) { //最初买入 if (buy == -1) buy = prices[i]; else { profit = profit + prices[i - 1] - buy; buy = prices[i]; } } else { if (buy == -1) buy = prices[i - 1]; } } //比较最后一个数字是否比买入时候贵 if (prices[prices.length - 1] &gt; buy) profit = profit + prices[prices.length - 1] - buy; return profit; }}","link":"/2020/01/05/算法/数组/买卖股票的最佳时机2/"},{"title":"Excel表列序号","text":"题目 给定一个Excel表格中的列名称，返回其相应的列序号。 例如， A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 ... 示例 1:** 12输入: &quot;A&quot;输出: 1 示例 2: 12输入: &quot;AB&quot;输出: 28 示例 3: 12输入: &quot;ZY&quot;输出: 701 思路： 因为字母代表的数字从 1 开始，因此，每位在乘以进制之前+1很关键 实现： 123456789101112class Solution { public int titleToNumber(String s) { int res = 0; int car = 1; for (int i = s.length() - 1; i &gt;= 0; i--) { res += (s.charAt(i) - 'A' + 1) * car; car *= 26; } return res; }}","link":"/2020/01/07/算法/数组/Excel表列序号/"},{"title":"二进制求和","text":"题目 给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1: 12输入: a = &quot;11&quot;, b = &quot;1&quot;输出: &quot;100&quot; 示例 2: 12输入: a = &quot;1010&quot;, b = &quot;1011&quot;输出: &quot;10101&quot; 思路： 从低位到高位依次计算 设置当前位num 设置进位carry 代码： 1234567891011121314151617181920212223242526272829303132333435363738package array.二进制求和;public class Solution { public String addBinary(String a, String b) { int n = a.length() - 1; int m = b.length() - 1; int carry = 0; StringBuilder sb = new StringBuilder(); while (n &gt;= 0 &amp;&amp; m &gt;= 0) { int num = a.charAt(n) - '0' + b.charAt(m) - '0' + carry; carry = num / 2; num = num % 2; sb.append(num); n--; m--; } while (n &gt;= 0) { int num = a.charAt(n) + carry - '0'; carry = num / 2; num = num % 2; sb.append(num); n--; } while (m &gt;= 0) { int num = b.charAt(m) - '0' + carry; carry = num / 2; num = num % 2; sb.append(num); m--; } if (carry &gt; 0) sb.append(carry); return sb.reverse().toString(); }}","link":"/2020/01/04/算法/数组/二进制求和/"},{"title":"乘积最大子序列","text":"题目 给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1: 123输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 123输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 思路： 先确定是否添加当前的数字，并且把添加与不添加的最大值保存下来 设置一个保存结果的值，将中间最大的值保存下来作为结果返回 实现： 123456789101112131415161718192021222324252627282930313233class Solution { public int maxProduct(int[] nums) { if (nums == null || nums.length == 0) return 0; int res = nums[0]; //取数组长度 int n = nums.length; //建立dp数组 int[][] dp = new int[n][2]; //初始化dp数组 dp[0][0] = nums[0]; dp[0][1] = nums[0]; for (int i = 1; i &lt; n; i++) { //取最小值 dp[i][0] = Math.min(nums[i], nums[i] * dp[i - 1][0]); dp[i][0] = Math.min(dp[i][0], nums[i] * dp[i - 1][1]); //取最大值 dp[i][1] = Math.max(nums[i], nums[i] * dp[i - 1][1]); dp[i][1] = Math.max(dp[i][1], nums[i] * dp[i - 1][0]); //将当前的最大值和res的最大值赋值给res res = Math.max(res, dp[i][1]); } return res; }}","link":"/2020/01/15/算法/数组/乘积最大子序列/"},{"title":"两数之和 II - 输入有序数组","text":"题目 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 123输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 思路： 列表从后往前遍历，看看目标减去当前值是否在当前值前面的集合里 暴力两层循环，查找是否存在加起来的和等于目标值 实现： 123456789101112131415161718192021class Solution { public int[] twoSum(int[] numbers, int target) { int[] res = new int[2]; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int number : numbers) { list.add(number); } for (int i = list.size() - 1; i &gt; 0; i--) { int sub = target - list.get(i); list.remove(i); if (list.contains(sub)) { res[0] = list.indexOf(sub) + 1; res[1] = i + 1; break; } } return res; }} 12345678910111213141516171819202122class Solution { public int[] twoSum(int[] numbers, int target) { int[] res = new int[2]; boolean flag = true; for (int i = 0; i &lt; numbers.length - 1; i++) { if (flag) { //判断是否找到所需结果 for (int j = i + 1; j &lt; numbers.length; j++) { if (numbers[i] + numbers[j] == target) { res[0] = i + 1; res[1] = j + 1; flag = false; break; }else if(numbers[i] + numbers[j] &gt; target) //当加起来的和超过目标值结束此轮循环 break; } } else break; } return res; }}","link":"/2020/01/06/算法/数组/两数之和II - 输入有序数组/"},{"title":"买卖股票的最佳时机","text":"题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2:** 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路： 找出后面的值减去前面值的最大值 实现： 12345678910111213class Solution { public int maxProfit(int[] prices) { int maxNum = 0; for (int i = 0; i &lt; prices.length - 1; i++) { for (int j = i + 1; j &lt; prices.length; j++) { int num = prices[j] - prices[i]; maxNum = num &gt; maxNum ? num : maxNum; } } return maxNum; }}","link":"/2020/01/05/算法/数组/买卖股票的最佳时机/"},{"title":"位1的个数","text":"题目 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 示例 1： 123输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &apos;1&apos;。 示例 2： 123输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &apos;1&apos;。 示例 3： 123输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &apos;1&apos;。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 进阶:如果多次调用这个函数，你将如何优化你的算法？ 思路： 方法一：直接使用java自带的函数Integer.bitCount(n) 方法二：使用位运算，统计1的数量 方法三：将n使用函数Integer.toBinaryString()转换成二进制字符串形式，统计1的个数 实现： 方法一： 123456public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { return Integer.bitCount(n); }} 方法二 1234567891011121314public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { int count = 32; int res = 0; while (count-- &gt; 0) { res += n &amp; 1; n &gt;&gt;= 1; } return res; }}","link":"/2020/01/08/算法/数组/位1的个数/"},{"title":"删除排序数组中的重复项","text":"题目 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) { print(nums[i]);} 思路： 采用双指针，把不相同的元素全部复制到数组的最前面 过程：如果连续两个元素相同，后边的指针+1，一直跳到不相同的元素为止 实现： 123456789101112131415161718class Solution { public int removeDuplicates(int[] nums) { int i = 0; int j = 1; while (j &lt; nums.length) { if (nums[i] == nums[j]) j++; else { i++; nums[i] = nums[j]; j++; } } return i + 1; }}","link":"/2020/01/14/算法/数组/删除排序数组中的重复项/"},{"title":"合并两个有序数组","text":"题目 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例： 123456789输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路： 先插入数字，然后整体排序 一边比较一边插入 实现： 12345678910111213141516171819202122232425262728293031package array.合并两个有序数组;public class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { //从数组尾端开始比较 int i = m - 1, j = n - 1, flag = 0; while (i &gt;= 0 &amp;&amp; j &gt;= 0) { if (nums1[i] &lt;= nums2[j]) { insertNum(nums1, i + 1, nums2[j]); j--; flag++; } else i--; } //检查nums2中元素是否全部插入nums1 if (flag != n) { for (int k = n - flag - 1; k &gt;= 0; k--) { insertNum(nums1, 0, nums2[k]); } } } //数组插入下标为index位置元素num private void insertNum(int[] nums, int index, int num) { for (int i = nums.length - 1; i &gt; index; i--) { nums[i] = nums[i - 1]; } nums[index] = num; }}","link":"/2020/01/04/算法/数组/合并两个有序数组/"},{"title":"删除排序数组中的重复项 II","text":"题目 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 12345给定 nums = [1,1,1,2,2,3],函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。你不需要考虑数组中超出新长度后面的元素。 示例 2: 12345给定 nums = [0,0,1,1,1,1,2,3,3],函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) { print(nums[i]);} 思路： 最重要的宗旨：任意一个位置的数字，只要和这个位置-2的位置数字不同，则一定可以放在当前的位置 实现： 12345678910111213141516171819202122232425class Solution { public int removeDuplicates(int[] nums) { if (nums == null || nums.length == 0) return 0; //当数组长度小于等于2时 if (nums.length &lt; 3) { return nums.length; } //定义遍历指针和数字有效长度指针 int i = 2, len = 2; //开始遍历数组 while (i &lt; nums.length) { if (nums[i] == nums[len - 2]) { i++; } else { nums[len++] = nums[i++]; } } return len; }}","link":"/2020/01/13/算法/数组/删除排序数组中的重复项II/"},{"title":"合并区间","text":"题目 给出一个区间的集合，请合并所有重叠的区间。 示例 1: 123输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 123输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 思路： 按照区间首位排序 取第一个区间设置为当前区间 将当前区间的末尾和循环中此时的区间首位作比较 当前区间的末尾小于循环中此时的区间首位 将当前区间加入到结果集当中 将循环中的此区间赋值给当前区间 当前区间的末尾大于等于循环中此时的区间首位 比较两个区间末尾，将大的值赋值给当前区间的末尾 循环结束后，将当前区间加入到结果集中 实现： 12345678910111213141516171819202122232425262728293031323334class Solution { public int[][] merge(int[][] intervals) { if (intervals == null || intervals.length == 0) return intervals; //存放结果 List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); //按照区间首位排序 Arrays.sort(intervals, (a, b) -&gt; a[0] - b[0]); //当前的区间 int[] cur = intervals[0]; for (int i = 0; i &lt; intervals.length; i++) { if (cur[1] &lt; intervals[i][0]) { list.add(cur); cur = intervals[i]; } else { cur[1] = Math.max(cur[1], intervals[i][1]); } } //将当前区间加入结果集中 list.add(cur); int[][] result = new int[list.size()][2]; for (int i = 0; i &lt; list.size(); i++) { result[i] = list.get(i); } return result; }}","link":"/2020/01/11/算法/数组/合并区间/"},{"title":"单词搜索","text":"题目 给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: 12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]给定 word = &quot;ABCCED&quot;, 返回 true.给定 word = &quot;SEE&quot;, 返回 true.给定 word = &quot;ABCB&quot;, 返回 false. 思路： 遍历矩阵中的每一个字符，使用DFS搜索 DFS算法 if(当前单词下标 = 单词长度) 则说明前面的字符完全对的上，返回true if(当前要访问的矩阵下标越界 || 当前位置 ！= 单词当前下标的字符) 返回false 设置一个保存结果的boolean变量，并且给当前位置元素做标记（代表已经访问过） 继续向四个方向递归，将返回结果赋值给上一步定义的booean变量 将标记位置赋值回原来的元素（恰好是目标单词当前下标的字符） 实现： 12345678910111213141516171819202122232425262728293031323334353637383940class Solution { public boolean exist(char[][] board, String word) { if (board == null || board.length == 0 || board[0].length == 0 || word == null || word.length() == 0) return false; //找到搜索的入口 for (int i = 0; i &lt; board.length; i++) { for (int j = 0; j &lt; board[0].length; j++) { if (dfs(board, word, i, j, 0)) return true; } } return false; } private boolean dfs(char[][] board, String word, int i, int j, int cur) { //查找成功 if (cur == word.length()) return true; //查找失败的某情形之一 if (i &lt; 0 || i &gt; board.length - 1 || j &lt; 0 || j &gt; board[0].length - 1 || board[i][j] != word.charAt(cur)) return false; //存放当前返回值 boolean isFound = false; //遍历过的位置做标记 board[i][j] = '*'; //遍历四个方向 isFound = dfs(board, word, i + 1, j, cur + 1) || dfs(board, word, i - 1, j, cur + 1) || dfs(board, word, i, j + 1, cur + 1) || dfs(board, word, i, j - 1, cur + 1); //将标记还原 board[i][j] = word.charAt(cur); return isFound; }}","link":"/2020/01/13/算法/数组/单词搜索/"},{"title":"子集","text":"题目 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 思路： 使用深度优先的组合算法 实现： 12345678910111213141516171819202122class Solution { public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { //存放结果 List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); //不重复的全部组合情况 dfs(results,new ArrayList&lt;&gt;(),nums,0); return results; } private void dfs(List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; result, int[] nums, int level) { results.add(new ArrayList&lt;&gt;(result)); for (int i = level; i &lt; nums.length; i++) { result.add(nums[i]); dfs(results, result, nums, i + 1); result.remove(result.size() - 1); } }}","link":"/2020/01/13/算法/数组/子集/"},{"title":"在排序数组中查找元素的第一个和最后一个位置","text":"题目 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例 1: 12输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2: 12输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 思路： 采用二分法，直到找到第一个相等的值，然后前后遍历找边界 实现： 1234567891011121314151617181920212223242526272829303132333435class Solution { public int[] searchRange(int[] nums, int target) { int head = 0; int rear = nums.length - 1; //存放结果 int[] ints = {-1, -1}; while (head &lt;= rear) { int mid = (head + rear) / 2; if (nums[mid] == target) { //遍历找尾 for (int i = mid; i &lt; nums.length; i++) { if (nums[i] == target) { ints[1] = i; } else break; } //遍历找头部 for (int i = mid; i &gt;= 0; i--) { if (nums[i] == target) { ints[0] = i; } else break; } //结束while循环 break; } else if (target &gt; nums[mid]) head = mid + 1; else rear = mid - 1; } return ints; }}","link":"/2020/01/10/算法/数组/在排序数组中查找元素的第一个和最后一个位置/"},{"title":"寻找峰值","text":"题目 峰值元素是指其值大于左右相邻值的元素。 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞。 示例 1: 123输入: nums = [1,2,3,1]输出: 2解释: 3 是峰值元素，你的函数应该返回其索引 2。 示例 2: 1234输入: nums = [1,2,1,3,5,6,4]输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 说明: 你的解法应该是 O(logN) 时间复杂度的。 思路： 用二分法的思想 由于相邻的值不会相等，所以比较中间值与下一个值得大小 比下一个值大，说明峰值在此数字和此数字之前，因此 rear = mid 比下一个值小，说明峰值一定在此值之后，因此 head = mid + 1 实现： 123456789101112131415161718class Solution { public int findPeakElement(int[] nums) { //顶替头尾指针 int head = 0; int rear = nums.length - 1; while (head &lt; rear) { int mid = head + (rear - head) / 2; if (nums[mid] &gt; nums[mid + 1]) rear = mid; else head = mid + 1; } return head; }}","link":"/2020/01/16/算法/数组/寻找峰值/"},{"title":"多数元素","text":"题目 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 123456输入: [3,2,3]输出: 3示例 2:输入: [2,2,1,1,1,2,2]输出: 2 思路： 遍历数组，找出大于数组一半长度的元素 利用哈希表，得出出现最多的元素（应对大多数情况） 实现: 12345678910111213141516171819202122class Solution { public int majorityElement(int[] nums) { if (nums.length == 1) return nums[0]; Arrays.sort(nums); int res = 0; int count = 0; int minCount = nums.length / 2; for (int i = 0; i &lt; nums.length - 1; i++) { if (nums[i] == nums[i + 1]) { count++; if (count &gt;= minCount) res = nums[i]; } else { count = 0; } } return res; }}","link":"/2020/01/07/算法/数组/多数元素/"},{"title":"子集 II","text":"题目 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 123456789输入: [1,2,2]输出:[ [2], [1], [1,2,2], [2,2], [1,2], [] 思路： 排序+全组合 实现: 1234567891011121314151617181920class Solution { public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) { Set&lt;List&lt;Integer&gt;&gt; results = new HashSet&lt;&gt;(); Arrays.sort(nums); dfs(results, new ArrayList&lt;&gt;(), nums, 0); List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;(results); return lists; } private void dfs(Set&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; result, int[] nums, int level) { results.add(new ArrayList&lt;&gt;(result)); for (int i = level; i &lt; nums.length; i++) { result.add(nums[i]); dfs(results, result, nums, i + 1); result.remove(result.size() - 1); } }}","link":"/2020/01/15/算法/数组/子集II/"},{"title":"搜索二维矩阵","text":"题目 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1: 12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3输出: true 示例 2: 12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13输出: false 思路： 和每一行的最后一个数字比较，确定了行 如果超过最大行，则返回false 没超过最大行的话在此行遍历查找 实现: 123456789101112131415161718192021222324252627282930313233343536class Solution { public boolean searchMatrix(int[][] matrix, int target) { if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false; //获取数组的行、列 int m = matrix.length; int n = matrix[0].length; //确定目标数值所在的行 int i = 0; for (; i &lt; m; i++) { if (target &lt;= matrix[i][n - 1]) break; } //如果i比最后一个数字大则直接返回 if (i &gt;= m) return false; //遍历这一行，查找目标数值（使用二分查找） int head = 0; int rear = n - 1; while (head &lt;= rear) { int mid = (head + rear) / 2; if (target == matrix[i][mid]) return true; else if (target &gt; matrix[i][mid]) head = mid + 1; else rear = mid - 1; } return false; }}","link":"/2020/01/13/算法/数组/搜索二维矩阵/"},{"title":"寻找旋转排序数组中的最小值","text":"题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1: 12输入: [3,4,5,1,2]输出: 1 示例 2: 12输入: [4,5,6,7,0,1,2]输出: 0 思路： 跟查找旋转数组目标值的思路一样，但是在定上下界的时候，直接将mid值赋值给上下边界值，因为找目标值的时候首先判断mid值，所以在后续赋值的时候上下界直接给mid值，而不是mid+1或mid-1 实现： 12345678910111213141516171819202122232425class Solution { public int findMin(int[] nums) { if (nums == null || nums.length == 0) return 0; int head = 0; int rear = nums.length - 1; while (head &lt;= rear) { int mid = head + (rear - head) / 2; if (nums[mid] &gt;= nums[head] &amp;&amp; nums[mid] &lt;= nums[rear]) return nums[head]; if (nums[mid] &gt; nums[head]) head = mid; else if (nums[mid] &lt; nums[head]) rear = mid; else return Math.min(nums[mid], nums[rear]); } return 0; }}","link":"/2020/01/16/算法/数组/寻找旋转排序数组中的最小值/"},{"title":"打家劫舍","text":"题目 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 1234输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 1234输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 思路： 使用动态规划，建立一个 n * 2 的二维数组，存放此位置偷与不偷的最大值 实现： 1234567891011121314151617181920212223242526class Solution { public int rob(int[] nums) { if (nums == null || nums.length == 0) return 0; int n = nums.length; //存放每个数值偷与不偷的最大值 int[][] dp = new int[n][2]; //不偷 dp[0][0] = 0; //偷 dp[0][1] = nums[0]; for (int i = 1; i &lt; nums.length; i++) { //因为此位置不偷，因此赋值上一次偷的最大值 dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]); //因为此次要偷，所以上一次不能偷，而是上一次不偷加此位置偷得的值 dp[i][1] = dp[i - 1][0] + nums[i]; } return Math.max(dp[n - 1][0], dp[n - 1][1]); }}","link":"/2020/01/08/算法/数组/打家劫舍/"},{"title":"打家劫舍 II","text":"题目 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 123输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2: 1234输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 思路： 环状排列意味着第一个房子和最后一个房子中只能选择一个偷窃，因此可以把此环状排列房间问题约化为两个单排排列房间子问题： 在不偷窃第一个房子的情况下（即 nums[1:]num**s[1:]），最大金额是 p1 在不偷窃最后一个房子的情况下（即 nums[:n-1]num**s[:n−1]），最大金额是 p2 综合偷窃最大金额： 为以上两种情况的较大值，即 max(p1,p2)max(p1,p2) 实现: 123456789101112131415161718192021222324252627282930313233class Solution { public int rob(int[] nums) { if (nums == null || nums.length == 0) return 0; if (nums.length == 1) return nums[0]; //不选第一家 int noFirst = steal(Arrays.copyOfRange(nums, 1, nums.length)); //不选最后一家 int noLast = steal(Arrays.copyOfRange(nums, 0, nums.length - 1)); return Math.max(noFirst, noLast); } public int steal(int[] nums) { int n = nums.length; int[][] dp = new int[n][2]; dp[0][0] = 0; dp[0][1] = nums[0]; for (int i = 1; i &lt; nums.length; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]); dp[i][1] = dp[i - 1][0] + nums[i]; } return Math.max(dp[n - 1][0], dp[n - 1][1]); }}","link":"/2020/01/08/算法/数组/打家劫舍II/"},{"title":"搜索旋转排序数组","text":"题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2: 12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 思路： 根据题目要求，一定是用二分法 先根据nums[mid]和nums[0]的关系分清楚是下面哪种情况： 然后再根据target和nums[0] 划分更细致的情况 实现: 1234567891011121314151617181920212223242526272829303132333435class Solution { public int search(int[] nums, int target) { int head = 0; int rear = nums.length - 1; while (head &lt;= rear) { int mid = (head + rear) / 2; if (nums[mid] == target) return mid; else if (target &gt; nums[mid]) { if (nums[mid] &lt; nums[0]) { if (target &lt; nums[0]) { head = mid + 1; } else { rear = mid - 1; } } else { head = mid + 1; } } else { if (nums[mid] &lt; nums[0]) { rear = mid - 1; } else { if (target &lt; nums[0]) { head = mid + 1; } else { rear = mid - 1; } } } } return -1; }}","link":"/2020/01/10/算法/数组/搜索旋转排序数组/"},{"title":"搜索旋转排序数组 II","text":"题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 示例 1: 12输入: nums = [2,5,6,0,0,1,2], target = 0输出: true 示例 2: 12输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 进阶: 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ 思路： 第一类101111 和 11101 这种。此种情况下 nums[head] == nums[mid]，分不清到底是前面有序还是后面有序，此时 head++ 即可。相当于去掉一个重复的干扰项。 第二类2345671 这种，也就是 nums[head] &lt; nums[mid]。此例子中就是 2 &lt; 5；这种情况下，前半部分有序。因此如果 nums[head] &lt;=target&lt;nums[mid]，则在前半部分找，否则去后半部分找。 第三类6712345这种，也就是 nums[head] &gt; nums[mid]。此例子中就是 6 &gt; 2；这种情况下，后半部分有序。因此如果 nums[mid] &lt;target&lt;=nums[rear]。则在后半部分找，否则去前半部分找。 实现： 12345678910111213141516171819202122232425262728293031323334353637class Solution { public boolean search(int[] nums, int target) { if (nums == null || nums.length == 0) return false; //设置头尾两个指针 int head = 0, rear = nums.length - 1; //分情况的二分查找 while (head &lt;= rear) { int mid = head + (rear - head) / 2; if (nums[mid] == target) return true; if (nums[mid] == nums[head]) { head++; continue; } //前半部分有序 if (nums[mid] &gt; nums[head]) { if (target &gt;= nums[head] &amp;&amp; target &lt; nums[mid]) rear = mid - 1; else head = mid + 1; } else { if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[rear]) head = mid + 1; else rear = rear - 1; } } return false; }}","link":"/2020/01/13/算法/数组/搜索旋转排序数组II/"},{"title":"最后一个单词的长度","text":"题目 给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明： 一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 12输入: &quot;Hello World&quot;输出: 5 思路：** 分割成string数组，直接输出最后一个位置单词的长度 实现： 1234567891011package array.最后一个单词的长度;public class Solution { public int lengthOfLastWord(String s) { String[] split = s.split(\" \"); if (split.length &gt; 0) return split[split.length - 1].length(); else return 0; }}","link":"/2020/01/04/算法/数组/最后一个单词的长度/"},{"title":"旋转数组","text":"题目 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的 原地 算法。 思路： 找出数组真正旋转的次数，由于旋转后数组一定序列的数字相对位置一定，新建两个数组以k为界，分为两个数组，然后前后颠倒再赋值给原数组 实现： 1234567891011121314151617181920212223242526272829303132class Solution { public void rotate(int[] nums, int k) { //当旋转次数为数组长度的倍数时，数组旋转回了最开始的样子，所以只需要计算出真正旋转的次数 k = k % nums.length; //存放最后K个元素之前的元素 int[] pre = new int[nums.length - k]; //存放最后K个元素 int[] back = new int[k]; //找出最后K个元素之前的元素 for (int i = 0; i &lt; nums.length - k; i++) { pre[i] = nums[i]; } //找出最后k个元素 for (int i = nums.length - k; i &lt; nums.length; i++) { back[i - nums.length + k] = nums[i]; } //重新给数组赋值 for (int i = 0; i &lt; k; i++) { nums[i] = back[i]; } for (int i = k; i &lt; nums.length; i++) { nums[i] = pre[i - k]; } }}","link":"/2020/01/07/算法/数组/旋转数组/"},{"title":"旋转图像","text":"题目 给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1: 12345678910111213给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例 2: 123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], 原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 思路： 行列互换 按列互换位置 实现 123456789101112131415161718192021222324252627class Solution { public void rotate(int[][] matrix) { int n = matrix.length; //行列互换 for (int i = 0; i &lt; n - 1; i++) { for (int j = i + 1; j &lt; n; j++) { matrix[i][j] = matrix[i][j] ^ matrix[j][i]; matrix[j][i] = matrix[i][j] ^ matrix[j][i]; matrix[i][j] = matrix[i][j] ^ matrix[j][i]; } } //左右列互换 for (int i = 0; i &lt; n; i++) { int head = 0; int rear = n - 1; while (head &lt; rear) { matrix[i][head] = matrix[i][head] ^ matrix[i][rear]; matrix[i][rear] = matrix[i][head] ^ matrix[i][rear]; matrix[i][head] = matrix[i][head] ^ matrix[i][rear]; head++; rear--; } } }}","link":"/2020/01/11/算法/数组/旋转图像/"},{"title":"最小路径和","text":"题目 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 思路： 使用动态规划的思想，求出到达当前格子的最小步数 先初始化靠上边和左侧边 剩下的当前格子步数加上左、上最小的步数则为当前最小步数 返回最后一个格子的步数则为最小值 实现： 1234567891011121314151617181920212223242526272829class Solution { public int minPathSum(int[][] grid) { if (grid == null || grid.length == 0) return 0; //数组的行、列 int m = grid.length; int n = grid[0].length; //初始化dp数组的第一行第一列 for (int j = 0; j &lt; n - 1; j++) { grid[0][j + 1] += grid[0][j]; } for (int i = 0; i &lt; m - 1; i++) { grid[i + 1][0] += grid[i][0]; } //计算动态数组的每一项 for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]); } } //返回结果值 return grid[m - 1][n - 1]; }}","link":"/2020/01/12/算法/数组/最小路径和/"},{"title":"最小栈","text":"题目 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 示例: 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 思路： 建立两个栈，一个保存栈的值，另一个保存最小值 实现： 123456789101112131415161718192021222324252627282930313233class MinStack { Stack&lt;Integer&gt; stack; Stack&lt;Integer&gt; min; /** * initialize your data structure here. */ public MinStack() { stack = new Stack&lt;&gt;(); min = new Stack&lt;&gt;(); } public void push(int x) { stack.push(x); if (min.isEmpty() || min.peek() &gt;= x) min.push(x); } public void pop() { int num = stack.pop(); if (!min.isEmpty() &amp;&amp; min.peek() == num) min.pop(); } public int top() { return stack.peek(); } public int getMin() { return min.peek(); }}","link":"/2020/01/06/算法/数组/最小栈/"},{"title":"最接近的三数之和","text":"题目 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 思路： 半暴力 + 双指针 实现： 123456789101112131415161718192021222324252627282930313233343536373839class Solution { public int threeSumClosest(int[] nums, int target) { Arrays.sort(nums); //存放结果 int res = 0; //存放最小距离 int abs = Integer.MAX_VALUE; for (int i = 0; i &lt; nums.length - 2; i++) { //头指针 int head = i + 1; //尾指针 int rear = nums.length - 1; while (head &lt; rear) { int sum = nums[i] + nums[head] + nums[rear]; if (sum &gt; target) { if (sum - target &lt; abs) { res = sum; abs = sum - target; } rear--; } else if (sum &lt; target) { if (target - sum &lt; abs){ res = sum; abs = target - sum; } head++; } else return target; } } return res; }}","link":"/2020/01/09/算法/数组/最接近的三数之和/"},{"title":"杨辉三角2","text":"题目 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 12输入: 3输出: [1,3,3,1] 思路：** 实现： 1234567891011121314151617181920212223242526import java.util.ArrayList;import java.util.List;class Solution { public List&lt;Integer&gt; getRow(int rowIndex) { //建立存放结果的集合 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); //添加第一行元素 List&lt;Integer&gt; firstRow = new ArrayList&lt;&gt;(); firstRow.add(1); res.add(firstRow); //根据杨辉三角的规则添加后面的行 for (int i = 1; i &lt;= rowIndex; i++) { List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); row.add(1); for (int j = 0; j &lt; res.get(i - 1).size() - 1; j++) { int num = res.get(i - 1).get(j) + res.get(i - 1).get(j + 1); row.add(num); } row.add(1); res.add(row); } return res.get(rowIndex); }}","link":"/2020/01/05/算法/数组/杨辉三角2/"},{"title":"杨辉三角","text":"题目 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 思路：** 根据动态规划的思想，按照杨辉三角的规则计算下一行的值 实现： 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.List;class Solution { public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) { //建立存放返回结果的集合 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (numRows == 0) return res; //添加杨辉三角的第一行（此时的杨辉三角至少有一行） List&lt;Integer&gt; firstRow = new ArrayList&lt;&gt;(); firstRow.add(1); res.add(firstRow); //处理后面的行 for (int i = 1; i &lt; numRows; i++) { List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); row.add(1); //利用杨辉三角的规则计算并添加下一行元素 for (int j = 0; j &lt; res.get(i - 1).size() - 1; j++) { int num = res.get(i - 1).get(j) + res.get(i - 1).get(j + 1); row.add(num); } //添加最后一列的1 row.add(1); res.add(row); } return res; }}","link":"/2020/01/05/算法/数组/杨辉三角/"},{"title":"爬楼梯","text":"题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 123456输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 1234567输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 思路： 找出递推公式 实现： 1234567891011121314151617181920212223class Solution { public int climbStairs(int n) { if (n&lt;1) return 0; if(n==1) return 1; if(n==2) return 2; int[] dp=new int[n+1]; dp[0]=0; dp[1]=1; dp[2]=2; for(int i=3;i&lt;=n;i++){ dp[i]=dp[i-1]+dp[i-2]; } return dp[n]; }}","link":"/2020/01/13/算法/数组/爬楼梯/"},{"title":"盛最多水的容器","text":"题目 给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 12输入: [1,8,6,2,5,4,8,3,7]输出: 49 思路： 暴力法，算出两两之间的面积求最大 双指针法： 由于高度小的限制了总面积，因此改变高度小的指针 实现： 暴力法 1234567891011121314151617class Solution { public int maxArea(int[] height) { if (height == null || height.length == 0 || height.length == 1) return 0; //存放最大值 int maxArea = 0; for (int i = 0; i &lt; height.length - 1; i++) { for (int j = i + 1; j &lt; height.length; j++) { maxArea = Math.max(maxArea, (j - i) * Math.min(height[i], height[j])); } } return maxArea; }} 双指针法 123456789101112131415161718class Solution { public int maxArea(int[] height) { int maxArea = 0; //存放面积的最大值 int head = 0; //头指针 int rear = height.length - 1; //尾指针 //由于高度小的限制了总面积，因此改变高度小的指针 while (head &lt; rear) { maxArea = Math.max((rear - head) * Math.min(height[head], height[rear]),maxArea); if (height[head] &gt; height[rear]) rear--; else head++; } return maxArea; }}","link":"/2020/01/08/算法/数组/盛最多水的容器/"},{"title":"组合总和","text":"题目 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1: 123456输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2: 1234567输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 思路： 使用深度优先的方法，对整个数组进行组合，找出符合题意的组合 实现： 1234567891011121314151617181920212223242526272829303132333435class Solution { public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(candidates); dfs(res, new ArrayList&lt;&gt;(), candidates, target, 0); return res; } /** * 深度优先遍历数组找出所有的排列组合 * * @param results 存放符合结果的数组结合 * @param result 存放当前组合 * @param candidates 要遍历的数组 * @param target 目标值 * @param level 当前层数 */ private void dfs(List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; result, int[] candidates, int target, int level) { //符合要求 if (target == 0) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(result); //添加到结果集 results.add(list); //返回上一层 return; } //查找 for (int i = level; i &lt; candidates.length &amp;&amp; target - candidates[level] &gt;= 0; i++) { result.add(candidates[i]); dfs(results, result, candidates, target - candidates[i], i); result.remove(result.size() - 1); } }} 深度遍历模板 1234567891011121314151617181920212223242526/** * 深度优先遍历数组找出所有的排列组合 * * @param results 存放符合结果的数组结合 * @param result 存放当前组合 * @param candidates 要遍历的数组 * @param target 目标值 * @param level 当前层数 */private void dfs(List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; result, int[] candidates, int target, int level) { //符合要求 if (target == 0) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(result); //添加到结果集 results.add(list); //返回上一层 return; } //查找 for (int i = level; i &lt; candidates.length &amp;&amp; target - candidates[level] &gt;= 0; i++) { result.add(candidates[i]); dfs(results, result, candidates, target - candidates[i], i); result.remove(result.size() - 1); }}","link":"/2020/01/10/算法/数组/组合总和/"},{"title":"螺旋矩阵","text":"题目 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1: 1234567输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5] 示例 2: 1234567输入:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]输出: [1,2,3,4,8,12,11,10,9,5,6,7] 思路： 先确定两个旋转方向数组 创建一个和原数组等大的访问数组，表示当前值是否被访问过 开始循环，一边添加当前下标的数据，一边判断方向是否需要改变 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { public List&lt;Integer&gt; spiralOrder(int[][] matrix) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (matrix == null || matrix.length == 0) { return list; } //数组的行列数 int n = matrix.length; int m = matrix[0].length; //定义旋转方向 int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; //定义当前方向下标 int i = 0; //定义访问数组，看元素是否被访问过 boolean[][] visited = new boolean[n][m]; //当前矩阵下标 int x = 0, y = 0; //循环插入结果集中数据 while (list.size() &lt; m * n) { list.add(matrix[x][y]); //访问标记 visited[x][y] = true; //判断方向是否需要改变 if (x + dx[i] &gt;= n || y + dy[i] &gt;= m || x + dx[i] &lt; 0 || y + dy[i] &lt; 0 || visited[x + dx[i]][y + dy[i]]) { i = (i + 1) % 4; } //得出下一个矩阵坐标 x += dx[i]; y += dy[i]; } return list; }}","link":"/2020/01/11/算法/数组/螺旋矩阵/"},{"title":"螺旋矩阵 II","text":"题目 给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例: 1234567输入: 3输出:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 思路： 设置方向数组 设置一个当前插入的值 开始循环插入 判断是否需要转向，转向的条件有 x，y方向超出下标范围时 方向不改变情况下下一个值已经插入时 实现： 12345678910111213141516171819202122232425262728293031323334353637383940class Solution { public int[][] generateMatrix(int n) { if (n &lt; 1) return new int[0][0]; //存放结果 int[][] res = new int[n][n]; //设置方向数组 int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; //设置方向索引 int dindex = 0; //当前插入的值 int cur = 0; //当前坐标 int x = 0; int y = 0; //循环插入值 for (int i = 0; i &lt; n * n; i++) { cur++; res[x][y] = cur; //判断是否需要改变方向 if (x + dx[dindex] &lt; 0 || x + dx[dindex] &gt; n - 1 || y + dy[dindex] &lt; 0 || y + dy[dindex] &gt; n - 1 || res[x + dx[dindex]][y + dy[dindex]] != 0) { dindex = (dindex + 1) % 4; } //生成下一个坐标 x += dx[dindex]; y += dy[dindex]; } return res; }}","link":"/2020/01/12/算法/数组/螺旋矩阵II/"},{"title":"矩阵置零","text":"题目 给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。 示例 1: 123456789101112输入: [ [1,1,1], [1,0,1], [1,1,1]]输出: [ [1,0,1], [0,0,0], [1,0,1]] 示例 2: 123456789101112输入: [ [0,1,2,0], [3,4,5,2], [1,3,1,5]]输出: [ [0,0,0,0], [0,4,5,0], [0,3,1,0]] 进阶: 一个直接的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。 你能想出一个常数空间的解决方案吗？ 思路： 新建两个数组，将需要变0的行、列分别存到两个数组中，遍历两个数组，将值变为0–空间复杂度O(m+n) 循环遍历两个，第一次改变行的值为0，并且在列为0的位置做记号，第二次遍历将做记号位置的列变为0 –空间复杂度O(1) 实现： 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { public void setZeroes(int[][] matrix) { if (matrix == null || matrix.length == 0) return; //获取矩阵的行、列 int m = matrix.length; int n = matrix[0].length; Set&lt;Integer&gt; rows = new HashSet&lt;&gt;(); Set&lt;Integer&gt; cols = new HashSet&lt;&gt;(); //遍历矩阵 for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { //找到0值 if (matrix[i][j] == 0) { //将需要变0的行存入数组 rows.add(i); //将需要变0的列存入数组 cols.add(j); } } } //行赋值0 for (Integer row : rows) { for (int j = 0; j &lt; n; j++) { matrix[row][j] = 0; } } //列赋值0 for (Integer col : cols) { for (int i = 0; i &lt; m; i++) { matrix[i][col] = 0; } } }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { public void setZeroes(int[][] matrix) { if (matrix == null || matrix.length == 0) return; //获取矩阵的行、列 int m = matrix.length; int n = matrix[0].length; //标记位 int flag = -99999999; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (matrix[i][j] == 0) { //将此行标记为0 for (int k = 0; k &lt; n; k++) { if (matrix[i][k] == 0) { //如果是0，则做标记，将来给列做记号 matrix[i][k] = flag; } else { //当前位置不是0，则变为0 matrix[i][k] = 0; } } break; } } } //改变列的值(纵向遍历) for (int j = 0; j &lt; n; j++) { for (int i = 0; i &lt; m; i++) { if (matrix[i][j] == flag) { //改变当列的值为0 for (int k = 0; k &lt; m; k++) { matrix[k][j] = 0; } break; } } } }}","link":"/2020/01/13/算法/数组/矩阵置零/"},{"title":"组合总和 II","text":"题目 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1: 12345678输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2: 123456输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 思路： 回溯法+DFS 实现： 1234567891011121314151617181920212223242526272829class Solution { public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { //存到集合中，防止元素重复 Set&lt;List&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;(); //必须先给数组排序 Arrays.sort(candidates); dfs(set, new ArrayList&lt;&gt;(), candidates, target, 0); List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(set); return results; } private void dfs(Set&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; result, int[] candidates, int target, int level) { if (target == 0) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(result); results.add(list); return; } //查找 for (int i = level; i &lt; candidates.length &amp;&amp; target - candidates[level] &gt;= 0; i++) { result.add(candidates[i]); //由于相同的元素只能用一回，因此下一次从i+1开始 dfs(results, result, candidates, target - candidates[i], i+1); result.remove(result.size() - 1); } }}","link":"/2020/01/10/算法/数组/组合总和II/"},{"title":"相交数组","text":"题目 编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 123输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 1234输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存 思路： 获取链表长度，然后从等长的长度开始遍历，寻找完全相同的节点 实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { //存放返回结果 ListNode res = null; //判断链表是否为空 if (headA == null || headB == null) return null; //获取链表长度 int lenA = getLength(headA); int lenB = getLength(headB); //创建遍历指针 ListNode nodeA = headA; ListNode nodeB = headB; //将链表调整到相等的长度 while (lenA != lenB) { if (lenA &gt; lenB) { nodeA = nodeA.next; lenA--; } else { nodeB = nodeB.next; lenB--; } } //遍历链表并比较 while (nodeA != null) { if (nodeA == nodeB) { res = nodeA; break; } nodeA = nodeA.next; nodeB = nodeB.next; } return res; } public static int getLength(ListNode node) { int len = 0; while (node != null) { len++; node = node.next; } return len; }}class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; }}","link":"/2020/01/06/算法/数组/相交数组/"},{"title":"颜色分类","text":"题目 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例: 12输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 思路： 计数排序 设置三个指针，分别表示0后的位置、2前的位置和当前遍历到的位置 当前值为0时，和0后位置交换然后两个指针++ 当前值为1时，cur++ 当前值为0时，和2前位置交换位置，指针向前一位 实现: 12345678910111213141516171819202122232425262728293031323334class Solution { public void sortColors(int[] nums) { if (nums == null || nums.length == 0) return; //设置三个值，保存每种颜色的数量 int count_0 = 0; int count_1 = 0; int count_2 = 0; //遍历数组 for (int i = 0; i &lt; nums.length; i++) { if (nums[i] == 0) count_0++; else if (nums[i] == 1) count_1++; else count_2++; } //重新写入数组 for (int i = 0; i &lt; count_0; i++) { nums[i] = 0; } for (int i = count_0; i &lt; count_0 + count_1; i++) { nums[i] = 1; } for (int i = count_0 + count_1; i &lt; nums.length; i++) { nums[i] = 2; } }} 一次遍历 12345678910111213141516171819202122232425262728293031class Solution { public void sortColors(int[] nums) { if (nums == null || nums.length == 0) return; int head = 0; //当前0的下一位 int rear = nums.length - 1; //当前遍历的位置 int cur = 0; //2的前一位 while (cur &lt;= rear) { if (nums[cur] == 0) { swap(nums, cur, head); cur++; head++; } else if (nums[cur] == 2) { swap(nums, cur, rear); rear--; } else cur++; } } private void swap(int[] nums, int i, int j) { if (i == j) return; nums[i] = nums[i] ^ nums[j]; nums[j] = nums[i] ^ nums[j]; nums[i] = nums[i] ^ nums[j]; }}","link":"/2020/01/13/算法/数组/颜色分类/"},{"title":"颠倒二进制位","text":"题目 颠倒给定的 32 位无符号整数的二进制位。 示例 1： 1234输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2： 1234输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 进阶:如果多次调用这个函数，你将如何优化你的算法？ 思路： 先将整数转换为二进制，然后倒序补0，输出的时候判断符号位，再将剩下的31位转换为10进制乘以对应的符号输出 位运算 位运算倒序万能模板 123456int n //要倒序的数字int ans = 0;{ ans = ans * 进制 + n % 进制; n /= 进制;} 实现： 1234567891011121314151617181920212223242526272829class Solution { public int reverseBits(int n) { String s = Integer.toBinaryString(n); StringBuilder sb = new StringBuilder(s); sb.reverse(); //补0 for (int i = s.length(); i &lt; 32; i++) { sb.append(0); } //存放结果 int res = 0; s= sb.toString(); //获取符号位 String bit = s.substring(0, 1); //获取数字位 String temp = s.substring(1); //判断符号位 if (bit.equals(\"0\")) res = Integer.parseInt(temp, 2); else res = -1 * (Integer.MAX_VALUE - Integer.parseInt(temp, 2) + 1); return res; }} 位运算 12345678910111213class Solution { public int reverseBits(int n) { int res = 0; int count = 32; while (count-- &gt; 0) { res = res &lt;&lt; 1; res += (n &amp; 1); n = n &gt;&gt; 1; } return res; }}","link":"/2020/01/07/算法/数组/颠倒二进制位/"},{"title":"跳跃游戏","text":"题目 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 123输入: [2,3,1,1,4]输出: true解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 示例 2: 123输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 思路： 设置一个值，表示能到达当前数字所需的最小步数 从后向前遍历整个数组，判断当前值是否大于最小值 如果大于设置的最小值，则将当前值设置为一个新的据点，判断前面的点能否到达这个值 如果小于设置的最小值，则最小值++，数组再往前挪一位继续判断 实现： 12345678910111213141516171819class Solution { public boolean canJump(int[] nums) { int minDistance = 0; for (int i = nums.length - 2; i &gt;= 0; i--) { //说明此点可以跳到下一个Good点，则将当前点设置为一个新的Good点 if (nums[i] &gt; minDistance) minDistance = 0; else //说明当前值不能跳到下一个good点，则继续向前判断，直到找到下一个Good点 minDistance++; } if (minDistance == 0) return true; else return false; }}","link":"/2020/01/11/算法/数组/跳跃游戏/"},{"title":"阶乘后的零","text":"题目 给定一个整数 n，返回 n! 结果尾数中零的数量。 示例 1: 123输入: 3输出: 0解释: 3! = 6, 尾数中没有零。 示例 2: 123输入: 5输出: 1解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 思路： 本题只说尾数中0的个数，因此只需要判断阶乘的过程中有多少个10，而10又是2和5组成的，有5就绝对有2或2的倍数，因此只需要判断数字中有几个5的因子 实现： 123456789101112class Solution { public int trailingZeroes(int n) { int res = 0; while (n != 0) { res += n / 5; n /= 5; } return res; }}","link":"/2020/01/07/算法/数组/阶乘后的零/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"位运算","slug":"位运算","link":"/tags/位运算/"},{"name":"虚拟机","slug":"虚拟机","link":"/tags/虚拟机/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"数组","slug":"数组","link":"/tags/数组/"},{"name":"动态规划","slug":"动态规划","link":"/tags/动态规划/"},{"name":"回溯法","slug":"回溯法","link":"/tags/回溯法/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"二分法","slug":"二分法","link":"/tags/二分法/"},{"name":"二维数组","slug":"二维数组","link":"/tags/二维数组/"},{"name":"贪心算法","slug":"贪心算法","link":"/tags/贪心算法/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"},{"name":"杂谈","slug":"java/杂谈","link":"/categories/java/杂谈/"},{"name":"虚拟机","slug":"java/虚拟机","link":"/categories/java/虚拟机/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"},{"name":"单例模式","slug":"设计模式/单例模式","link":"/categories/设计模式/单例模式/"},{"name":"算法","slug":"算法","link":"/categories/算法/"},{"name":"数组","slug":"算法/数组","link":"/categories/算法/数组/"},{"name":"动态规划","slug":"算法/动态规划","link":"/categories/算法/动态规划/"}]}