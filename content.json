{"pages":[],"posts":[{"title":"杂","text":"代码书写优化 尽量不要在finally中书写return语句","link":"/2019/12/26/杂/"},{"title":"虚拟机加载机制","text":"概述 类型的加载、连接和初始化都是在程序运行期间完成的（动态加载、动态连接），虽然会增加性能的开销，但是会提高java语言的动态扩展性 加载类的时机 有且只有以下5种情况类立即开始初始化（加载、验证、准备已完成），称为主动引用： 遇到new、getstatic、putstatic、或invokestatic这4条字节指令码时，如果类没有进行初始化则触发其初始化 使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行过初始化则立即初始化 当初始化一个类的时候其父类还没有进行初始化则对其父类先进行初始化（类对此有要求而接口没有，接口在用到其父类时再进行初始化） 虚拟机启动时，用户指定要执行的类（包含main方法的类），则对其进行初始化 jdk1.7的动态语言支持，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先初始化 除此之外，所有引用类的方式都不会触发初始化，这种引用方式称为被动引用，例如： 引用静态字段的时候只有定义静态字段的类会初始化，其子类在引用的时候子类不会初始化，只会初始化定义静态字段的父类 SuperClass[] sca=new SuperClass[]; 不会触发SuperClass的初始化（创建动作是newarray，不是new） 在一个类种有final修饰的静态属性，当对此属性引用时不会触发该类的初始化，因为在编译期间将此静态属性的值存储到了Notinitialization类的常量池中，此时引用的是Notinitialization的值，与定义此静态属性的类已经没有任何联系了 类加载的过程 加载 加载只是类加载的一个阶段 加载阶段，虚拟机需要完成三件事情：获取二进制字节流–&gt;根据二进制字节流构造数据结构–&gt;方法区中生成一个java.lang.Class对象 通过一个类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口 加载阶段和验证的部分阶段是交叉进行的 验证 文件格式验证：魔数、主次版本校验 元数据验证 字节码验证 符号引用验证 准备 此阶段为类变量（static）分配内存（在方法区中）并赋初始值，真正赋值则是在()方法中 final修饰的static变量则在准备阶段就进行了真正赋值 解析 将常量池中符号引用替换为直接引用的过程 ​","link":"/2019/12/26/虚拟机类加载机制/"},{"title":"类文件结构","text":"class类文件结构 知识点 class文件是一组以8位字节为基础的二进制流 class文件格式采用一种类似于c语言结构体的伪结构来存储数据，只包含两种类型：无符号数和表 无符号数:属于基本的数据类型，u1，u2到u8分别代表1，2，8个字节的无符号数，可以用来描述数字、索引引用、数量值或者utf-8编码构成的字符串值 表：由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性的以“_info”结尾 整个class文件本质上就是一张表 字节码 魔数与class文件的版本 每个class文件开头4个字节成为魔数，唯一的作用进行身份识别（比文件扩展名更加安全，因为扩展名可以随意修改） 第5、6个字节表示次版本号 第7、8个字节表示主版本号（JAVA主版本号从45开始） java的魔数是“0xCAFEBABE” 常量池 主次版本后就是常量池的入口，入口放置u2，表示常量池容量，从1开始 主要存放两大类常量：字面量和符号引用 字面量：接近java语言层面的常量概念，如：文本字符串、声明为final的常量值 符号引用：属于编译原理方面的概念，如：类和接口的全限定名、字段的名称和描述符、方法的名称和描述 符 访问标志 常量池结束后紧接的两个字节 这个标志用于识别一些类或者接口层次的访问信息，如：这个class是类还是接口、是否定义为public、是否定义为abstract类型、是否被声明为final 类索引、父类索引、接口索引 访问标志后的三个u2类型的数据分别表示类索引、父类索引、接口索引数量 字段表集合 方法表集合 属性表集合 字节码指令 知识点 java虚拟机指令：操作码（opcode）+操作数（oprands） 操作码大小为1个字节，所以操作码指令总数不可能超过256 加载和存储指令 加载（变量：load 常量:ipush）和存储（store）指令用于将数据在栈帧的局部变量表和操作数栈之间传输数据 slot_0 存放的四this 指令运算集 如果某个操作结果没有明确的数学定义，则使用NaN表示，NaN参与的所有运算结果都是NaN 类型转换指令 Java虚拟机支持的直接转换（无需显示转换）：小范围类型到大范围类型的安全转换 int到long、float、double long到float、double float到double 窄化类型转换（大范围类型到小范围类型的不安全转换）例如：i2b、l2i 转换结果可能产生不同的正负号、不同的数量级、导致精度丢失 long转int：丢弃高位，剩下32位，最高位则位正负号，则有可能出现与原来相反的符号 浮点数转整型： 浮点数是NaN，转换结果是0 浮点值不是无穷大的话，舍弃小数位的结果在整型范围内则直接舍弃小数位 浮点值不是无穷大的话，舍弃小数位的结果不在整型范围内，则根据浮点数的符号，表示位整型的最大或最小正数 对象创建与访问指令 创建类实例：new 创建数组：newarray、anewarray 访问类字段（static）：getstatic、putstatic 访问实例字段：getfield、putfield 将数组元素加载到操作数栈：_aload 将操作数栈中的元素存到数组中：_astore 取数组长度指令：arraylength 检查类实例类型：instanceof、checkcast 操作数栈管理指令 栈顶出栈元素：pop、pop2（出栈两个元素） 复制栈顶的值并重新压入栈中：dup、dup2（复制栈顶两个元素） 互换栈顶两个元素：swap 控制转移指令 条件分支：ifeq、iflt、ifnull 复合条件分支：tableswitch、lookupswitch 无条件分支：goto、goto_w、ret 方法调用和返回指令 invokevirtual 调用对象实例方法 invokeinterface 调用接口方法（找到实现此接口的方法进行调用） invokespecial 调用需要特殊处理的方法，例如：实例初始化方法、私有方法和父方法 invokestatic 调用类方法 invokedynamic ireturn（bool、byte、char、short、int）返回值类型 lreturn、freturn、dreturn、areturn 异常处理指令 同步指令 java虚拟机可以支持方法级同步和方法内部一段指令的同步，这两种同步都使用管程（Monitor）来支持","link":"/2019/12/25/类文件结构/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"虚拟机","slug":"虚拟机","link":"/tags/虚拟机/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"},{"name":"杂谈","slug":"java/杂谈","link":"/categories/java/杂谈/"},{"name":"虚拟机","slug":"java/虚拟机","link":"/categories/java/虚拟机/"}]}